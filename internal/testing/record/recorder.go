// Copyright 2025 Tom Barlow
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package record

import (
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"time"

	"gopkg.in/yaml.v3"
)

// Recorder captures real API responses and saves them as fixtures.
type Recorder struct {
	fixturesDir string
	redactor    *Redactor
	logger      *slog.Logger
}

// Config holds configuration for creating a Recorder.
type Config struct {
	// FixturesDir is the directory where recorded fixtures will be saved
	FixturesDir string

	// Redactor for scrubbing sensitive data (optional, uses default if nil)
	Redactor *Redactor

	// Logger for recording operations
	Logger *slog.Logger
}

// NewRecorder creates a new recorder with the given configuration.
func NewRecorder(cfg Config) (*Recorder, error) {
	if cfg.Logger == nil {
		cfg.Logger = slog.Default()
	}

	if cfg.Redactor == nil {
		cfg.Redactor = NewRedactor()
	}

	// Create .recorded directory if it doesn't exist
	recordedDir := filepath.Join(cfg.FixturesDir, ".recorded")
	if err := os.MkdirAll(recordedDir, 0750); err != nil {
		return nil, fmt.Errorf("failed to create recorded fixtures directory: %w", err)
	}

	return &Recorder{
		fixturesDir: cfg.FixturesDir,
		redactor:    cfg.Redactor,
		logger:      cfg.Logger,
	}, nil
}

// LLMResponse represents a recorded LLM response with metadata.
type LLMResponse struct {
	Response string            `yaml:"response" json:"response"`
	Metadata LLMResponseMeta   `yaml:"_metadata,omitempty" json:"_metadata,omitempty"`
	Comment  string            `yaml:"_comment,omitempty" json:"_comment,omitempty"`
}

// LLMResponseMeta contains metadata about a recorded LLM response.
type LLMResponseMeta struct {
	RecordedAt   string `yaml:"recorded_at" json:"recorded_at"`
	DurationMs   int64  `yaml:"duration_ms" json:"duration_ms"`
	Model        string `yaml:"model,omitempty" json:"model,omitempty"`
	PromptTokens int    `yaml:"prompt_tokens,omitempty" json:"prompt_tokens,omitempty"`
	CompletionTokens int `yaml:"completion_tokens,omitempty" json:"completion_tokens,omitempty"`
}

// HTTPResponse represents a recorded HTTP response with metadata.
type HTTPResponse struct {
	Request  HTTPRequest     `yaml:"request" json:"request"`
	Response HTTPResponseData `yaml:"response" json:"response"`
	Comment  string          `yaml:"_comment,omitempty" json:"_comment,omitempty"`
}

// HTTPRequest represents the HTTP request that was made.
type HTTPRequest struct {
	Method  string            `yaml:"method" json:"method"`
	URL     string            `yaml:"url" json:"url"`
	Headers map[string]string `yaml:"headers,omitempty" json:"headers,omitempty"`
	Body    interface{}       `yaml:"body,omitempty" json:"body,omitempty"`
}

// HTTPResponseData represents the HTTP response data.
type HTTPResponseData struct {
	Status  int               `yaml:"status" json:"status"`
	Headers map[string]string `yaml:"headers,omitempty" json:"headers,omitempty"`
	Body    interface{}       `yaml:"body,omitempty" json:"body,omitempty"`
}

// IntegrationResponse represents a recorded integration response.
type IntegrationResponse struct {
	Request  IntegrationRequest `yaml:"request" json:"request"`
	Response interface{}        `yaml:"response" json:"response"`
	Comment  string             `yaml:"_comment,omitempty" json:"_comment,omitempty"`
}

// IntegrationRequest represents the integration request that was made.
type IntegrationRequest struct {
	Operation string                 `yaml:"operation" json:"operation"`
	Params    map[string]interface{} `yaml:"params,omitempty" json:"params,omitempty"`
}

// RecordLLM records an LLM response to a fixture file.
func (r *Recorder) RecordLLM(stepID, response, model string, duration time.Duration, promptTokens, completionTokens int) error {
	// Redact sensitive data from the response
	redactedResponse := r.redactor.RedactString(response)

	fixture := LLMResponse{
		Response: redactedResponse,
		Metadata: LLMResponseMeta{
			RecordedAt:       time.Now().UTC().Format(time.RFC3339),
			DurationMs:       duration.Milliseconds(),
			Model:            model,
			PromptTokens:     promptTokens,
			CompletionTokens: completionTokens,
		},
		Comment: "Auto-generated by conductor run --record",
	}

	return r.writeFixture(stepID, fixture)
}

// RecordHTTP records an HTTP response to a fixture file.
func (r *Recorder) RecordHTTP(stepID, method, url string, reqHeaders map[string]string, reqBody interface{},
	status int, respHeaders map[string]string, respBody interface{}) error {

	// Redact sensitive data
	redactedReqHeaders := r.redactor.RedactHeaders(reqHeaders)
	redactedRespHeaders := r.redactor.RedactHeaders(respHeaders)
	redactedURL := r.redactor.RedactURL(url)

	// Redact request and response bodies
	redactedReqBody := r.redactBody(reqBody)
	redactedRespBody := r.redactBody(respBody)

	fixture := HTTPResponse{
		Request: HTTPRequest{
			Method:  method,
			URL:     redactedURL,
			Headers: redactedReqHeaders,
			Body:    redactedReqBody,
		},
		Response: HTTPResponseData{
			Status:  status,
			Headers: redactedRespHeaders,
			Body:    redactedRespBody,
		},
		Comment: "Auto-generated by conductor run --record",
	}

	return r.writeFixture(stepID, fixture)
}

// RecordIntegration records an integration response to a fixture file.
func (r *Recorder) RecordIntegration(stepID, operation string, params map[string]interface{}, response interface{}) error {
	// Redact params and response
	redactedParams := r.redactor.RedactMap(params)
	redactedResponse := r.redactValue(response)

	fixture := IntegrationResponse{
		Request: IntegrationRequest{
			Operation: operation,
			Params:    redactedParams,
		},
		Response: redactedResponse,
		Comment:  "Auto-generated by conductor run --record",
	}

	return r.writeFixture(stepID, fixture)
}

// redactBody redacts sensitive data from a request or response body.
func (r *Recorder) redactBody(body interface{}) interface{} {
	if body == nil {
		return nil
	}

	switch v := body.(type) {
	case string:
		return r.redactor.RedactString(v)
	case map[string]interface{}:
		return r.redactor.RedactMap(v)
	case []interface{}:
		return r.redactArray(v)
	default:
		// For other types, try to marshal to JSON, redact, and unmarshal back
		jsonBytes, err := json.Marshal(v)
		if err != nil {
			r.logger.Warn("Failed to marshal body for redaction", "error", err)
			return v
		}

		redactedJSON, err := r.redactor.RedactJSON(string(jsonBytes))
		if err != nil {
			r.logger.Warn("Failed to redact JSON body", "error", err)
			return v
		}

		var redacted interface{}
		if err := json.Unmarshal([]byte(redactedJSON), &redacted); err != nil {
			r.logger.Warn("Failed to unmarshal redacted body", "error", err)
			return v
		}

		return redacted
	}
}

// redactArray redacts sensitive data from an array.
func (r *Recorder) redactArray(arr []interface{}) []interface{} {
	result := make([]interface{}, len(arr))
	for i, v := range arr {
		result[i] = r.redactValue(v)
	}
	return result
}

// redactValue redacts a single value based on its type.
func (r *Recorder) redactValue(v interface{}) interface{} {
	if v == nil {
		return nil
	}

	switch val := v.(type) {
	case string:
		return r.redactor.RedactString(val)
	case map[string]interface{}:
		return r.redactor.RedactMap(val)
	case []interface{}:
		return r.redactArray(val)
	default:
		return val
	}
}

// writeFixture writes a fixture to the .recorded directory.
func (r *Recorder) writeFixture(stepID string, fixture interface{}) error {
	recordedDir := filepath.Join(r.fixturesDir, ".recorded")
	filePath := filepath.Join(recordedDir, stepID+".yaml")

	// Marshal to YAML
	data, err := yaml.Marshal(fixture)
	if err != nil {
		return fmt.Errorf("failed to marshal fixture: %w", err)
	}

	// Write with restricted permissions (NFR14)
	if err := os.WriteFile(filePath, data, 0600); err != nil {
		return fmt.Errorf("failed to write fixture file: %w", err)
	}

	r.logger.Info("[RECORD] Saved fixture", "step_id", stepID, "file", filePath)
	return nil
}
