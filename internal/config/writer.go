// Copyright 2025 Tom Barlow
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
	"context"
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

// WriteConfig writes a configuration to a YAML file
// It creates parent directories if they don't exist and sets appropriate permissions
func WriteConfig(cfg *Config, path string) error {
	// Expand home directory if present
	if len(path) > 0 && path[0] == '~' {
		home, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("failed to get home directory: %w", err)
		}
		path = filepath.Join(home, path[1:])
	}

	// Create parent directory if it doesn't exist
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0700); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Marshal to YAML
	data, err := yaml.Marshal(cfg)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	// Add header comment
	header := `# Conductor Configuration
# Generated by conductor init
#
# For more information, see: https://docs.conductor.dev/configuration
#
`
	content := header + string(data)

	// Write to file with secure permissions
	if err := os.WriteFile(path, []byte(content), 0600); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	return nil
}

// WriteConfigMinimal writes a minimal configuration with only essential fields
func WriteConfigMinimal(defaultProvider string, providers ProvidersMap, path string) error {
	cfg := &Config{
		DefaultProvider: defaultProvider,
		Providers:       providers,
	}
	return WriteConfig(cfg, path)
}

// WriteConfigWithSecrets writes a minimal configuration and stores API keys in secrets backend.
// API keys are stored as $secret:providers/<name>/api_key references.
// Returns the list of secret keys that were stored.
func WriteConfigWithSecrets(ctx context.Context, defaultProvider string, providers ProvidersMap, path string, backendName string) ([]string, error) {
	var storedKeys []string

	// Create secrets resolver
	resolver := createSecretResolver()

	// Process each provider to extract and store API keys
	for name, provider := range providers {
		if provider.APIKey != "" && !secretRefPattern.MatchString(provider.APIKey) {
			// This is a plaintext API key, store it in secrets
			secretKey := fmt.Sprintf("providers/%s/api_key", name)

			// Store in secrets backend
			if err := resolver.Set(ctx, secretKey, provider.APIKey, backendName); err != nil {
				return storedKeys, fmt.Errorf("failed to store secret for provider %q: %w", name, err)
			}

			// Update provider config to use secret reference
			provider.APIKey = fmt.Sprintf("$secret:%s", secretKey)
			providers[name] = provider

			storedKeys = append(storedKeys, secretKey)
		}
	}

	// Write config with secret references
	cfg := &Config{
		DefaultProvider: defaultProvider,
		Providers:       providers,
	}

	if err := WriteConfig(cfg, path); err != nil {
		return storedKeys, err
	}

	return storedKeys, nil
}
