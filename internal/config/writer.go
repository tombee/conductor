// Copyright 2025 Tom Barlow
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)

// WriteConfig writes a configuration to a YAML file atomically with backup.
// It creates parent directories if they don't exist and sets appropriate permissions.
// The write is atomic: creates a temp file, then renames it to the target path.
// If the config file already exists, it creates a timestamped backup and rotates old backups.
func WriteConfig(cfg *Config, path string) error {
	// Expand home directory if present
	if len(path) > 0 && path[0] == '~' {
		home, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("failed to get home directory: %w", err)
		}
		path = filepath.Join(home, path[1:])
	}

	// Create parent directory if it doesn't exist
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0700); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Validate directory permissions
	dirInfo, err := os.Stat(dir)
	if err != nil {
		return fmt.Errorf("failed to stat config directory: %w", err)
	}
	if dirInfo.Mode().Perm()&0077 != 0 {
		// Directory is readable/writable by group or others - warn but allow
		// (Some network filesystems don't support strict permissions)
	}

	// Marshal to YAML
	data, err := yaml.Marshal(cfg)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	// Add header comment
	header := `# Conductor Configuration
# Generated by conductor setup
#
# For more information, see: https://docs.conductor.dev/configuration
#
`
	content := header + string(data)

	// Create backup if file exists
	if _, err := os.Stat(path); err == nil {
		if err := createBackup(path); err != nil {
			return fmt.Errorf("failed to create backup: %w", err)
		}
	}

	// Write atomically using temp file + rename
	if err := writeAtomic(path, []byte(content), 0600); err != nil {
		return err
	}

	return nil
}

// createBackup creates a timestamped backup of the config file and rotates old backups.
// Keeps the last 3 backups, deleting older ones.
func createBackup(path string) error {
	// Read existing file
	data, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read existing config: %w", err)
	}

	// Create backup with timestamp (including milliseconds to avoid collisions in tests)
	timestamp := time.Now().Format("20060102-150405.000")
	backupPath := fmt.Sprintf("%s.bak.%s", path, timestamp)

	if err := os.WriteFile(backupPath, data, 0600); err != nil {
		return fmt.Errorf("failed to write backup: %w", err)
	}

	// Rotate old backups (keep last 3)
	if err := rotateBackups(path); err != nil {
		// Log warning but don't fail the operation
		fmt.Fprintf(os.Stderr, "Warning: failed to rotate old backups: %v\n", err)
	}

	return nil
}

// rotateBackups removes old backup files, keeping only the 3 most recent.
func rotateBackups(configPath string) error {
	dir := filepath.Dir(configPath)
	base := filepath.Base(configPath)
	prefix := base + ".bak."

	entries, err := os.ReadDir(dir)
	if err != nil {
		return err
	}

	// Find all backup files
	var backups []string
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		if strings.HasPrefix(entry.Name(), prefix) {
			backups = append(backups, filepath.Join(dir, entry.Name()))
		}
	}

	// Sort by name (timestamps are lexicographically sortable)
	sort.Strings(backups)

	// Keep last 3, delete the rest
	if len(backups) > 3 {
		for _, old := range backups[:len(backups)-3] {
			if err := os.Remove(old); err != nil {
				// Log but continue
				fmt.Fprintf(os.Stderr, "Warning: failed to remove old backup %s: %v\n", old, err)
			}
		}
	}

	return nil
}

// writeAtomic writes data to a file atomically by writing to a temp file
// and then renaming it to the target path. This ensures the file is never
// in a partially-written state.
func writeAtomic(path string, data []byte, perm os.FileMode) error {
	dir := filepath.Dir(path)
	base := filepath.Base(path)

	// Create temp file in same directory as target
	// (ensures atomic rename works across filesystem boundaries)
	tmpFile, err := os.CreateTemp(dir, base+".tmp.*")
	if err != nil {
		return fmt.Errorf("failed to create temp file: %w", err)
	}
	tmpPath := tmpFile.Name()

	// Ensure temp file is removed on error
	defer func() {
		if tmpFile != nil {
			tmpFile.Close()
			os.Remove(tmpPath)
		}
	}()

	// Write data to temp file
	if _, err := tmpFile.Write(data); err != nil {
		return fmt.Errorf("failed to write temp file: %w", err)
	}

	// Sync to ensure data is on disk
	if err := tmpFile.Sync(); err != nil {
		return fmt.Errorf("failed to sync temp file: %w", err)
	}

	// Close temp file
	if err := tmpFile.Close(); err != nil {
		return fmt.Errorf("failed to close temp file: %w", err)
	}
	tmpFile = nil // Mark as closed

	// Set permissions
	if err := os.Chmod(tmpPath, perm); err != nil {
		return fmt.Errorf("failed to set permissions on temp file: %w", err)
	}

	// Atomic rename
	if err := os.Rename(tmpPath, path); err != nil {
		return fmt.Errorf("failed to rename temp file: %w", err)
	}

	return nil
}

// WriteConfigMinimal writes a minimal configuration with only essential fields
func WriteConfigMinimal(providers ProvidersMap, path string) error {
	cfg := &Config{
		Providers: providers,
	}
	return WriteConfig(cfg, path)
}

// WriteConfigWithSecrets writes a minimal configuration and stores API keys in secrets backend.
// API keys are stored as $secret:providers/<name>/api_key references.
// Returns the list of secret keys that were stored.
func WriteConfigWithSecrets(ctx context.Context, providers ProvidersMap, path string, backendName string) ([]string, error) {
	var storedKeys []string

	// Create secrets resolver
	resolver := createSecretResolver()

	// Process each provider to extract and store API keys
	for name, provider := range providers {
		if provider.APIKey != "" && !secretRefPattern.MatchString(provider.APIKey) {
			// This is a plaintext API key, store it in secrets
			secretKey := fmt.Sprintf("providers/%s/api_key", name)

			// Store in secrets backend
			if err := resolver.Set(ctx, secretKey, provider.APIKey, backendName); err != nil {
				return storedKeys, fmt.Errorf("failed to store secret for provider %q: %w", name, err)
			}

			// Update provider config to use secret reference
			provider.APIKey = fmt.Sprintf("$secret:%s", secretKey)
			providers[name] = provider

			storedKeys = append(storedKeys, secretKey)
		}
	}

	// Write config with secret references
	cfg := &Config{
		Providers: providers,
	}

	if err := WriteConfig(cfg, path); err != nil {
		return storedKeys, err
	}

	return storedKeys, nil
}
